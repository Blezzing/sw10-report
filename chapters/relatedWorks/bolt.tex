\section{Bolt}
\textit{Bolt} is a library providing abstractions for heterogeneous computing. This section is based on \textit{Bolt}'s documentation\cite{boltDoc} and \textit{Github} page\cite{boltGithub}.

\subsection{Goals}
\textit{Bolt} is aim to provide high performance library implementations for common algorithms, following the structure of \textit{STL}. It is intended to make heterogeneous development easieran, and is designed to provide an application that can execute on either a CPU or any OpenCL capable unit.

\subsection{Programming Model}
\textit{Bolt} is modeled on \textit{STL} and as such, follows the model of calling functions with iterators as arguments to instruct where input and output is located.

It have functions for modifying \textit{STL} containers, and the library decides whether the computation should happen on host or device, involving any required copying.

The example shown in Listing \ref{code:boltSaxpy}, shows how well the library interfaces with an \textit{STL} vector.

From line \ref{code:boltSaxpy:cppamp} until the next comment it is shown how the function is defined and implemented with the \textit{C++ AMP} backend. It is done with a \textit{C++11} lambda and \textit{C++ AMP}'s restrict classifier.

From line \ref{code:boltSaxpy:opencl} it is shown how, instead of a lambda, a functor is needed when using the \textit{OpenCL} backend. The functor is then defined inside a BOLT\_FUNCTOR macro to statically generate relevant \textit{OpenCL} code.

\begin{lstlisting}[caption={Bolt \textit{SAXPY} example}, label={code:boltSaxpy}]
const size_t N = 1024;
int a = 10;

std::vector<int> x(N);
std::vector<int> y(N);
std::vector<int> z(N);

std::generate(x.begin(), x.end(), rand);
std::generate(y.begin(), y.end(), rand);

//bolt with c++ amp backend ~\label{code:boltSaxpy:cppamp}~
auto saxpyLambda = [=] (float xx, float yy) restrict(cpu,amp) {
  return a * xx + yy;
};
bolt::transform(x.begin(), x.end(), y.begin(), z.begin, saxpyLambda);

//bolt with opencl backend ~\label{code:boltSaxpy:opencl}~
BOLT_FUNCTOR(SaxpyFunctor,
  struct SaxpyFunctor{
    int _a;
    SaxpyFunctor(int a): _a(a) {};
    float operator() (const int& xx, const int& yy){
      return _a * xx + yy;
    };
  };
);
boltcl::transform(x.begin(), x.end(), y.begin(), z.begin, SaxpyFunctor(a));
\end{lstlisting}

\subsection{Implementation}
\textit{Bolt} is a library on top of either \textit{C++ AMP} or \textit{OpenCL}. The API is the same, while the supported features changes depending on what implementation is selected.
As shown in the example, only the \textit{C++ AMP} backend supports \textit{C++11} lambdas, which reduces the amount of work needed by the developer, compared to the functor.
%https://www.slideshare.net/hsafoundation/bolt-for-hsa-by-ben-sanders

\subsection{Key Points}
Being able to use the same algorithms on both \textit{STL} containers, and \textit{Bolts} containers can provide an easier transition.

Being a library on top of other frameworks results in some code artefacts. With \textit{C++ AMP} as target, the use of the restrict classifier on lambdas seem unergonomic. With \textit{OpenCL} as target, it is the use of \texttt{BOLT\_FUNCTOR} as a macro to overcome the language gap between \textit{C++} and \textit{OpenCL C}. Both examples show that workarounds to support the target sometimes will show up in the API. 

The usage of the containers is based on iterators, as \textit{STL} is, and can be very verbose with multiple operations on the same container.
