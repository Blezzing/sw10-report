\section{Architecture Design}
In this section we discuss the decisions made regarding the architecture of \textit{YAGAL}, including compilation method, run time, and compatibility.

\subsection{Using LLVM and CUDA Driver API}
In chapter \ref{cha:relatedWorks} we see that there are frameworks which use \textit{LLVM} to build a compiler that output either \textit{PTX} or \textit{SPIR} code. We also see that there are frameworks that without introducing a compiler translates to \textit{OpenCL} code. We have not found any that without a compiler translates to \textit{CUDA} or \textit{PTX}, we want to attempt this.

As \textit{LLVM Intermediate Representation} is a higher level language than \textit{PTX}, we still want to make use of \textit{LLVM}. The idiomatic use of \textit{LLVM} is to build a compiler with the passes provided by the \textit{LLVM}, and additional passes defined by the compiler developer, but as we want to avoid building a compiler that a developer is forced to use to use our framework, we can not do this. Instead we want to use the \textit{LLVM} framework by including it in our library in such a way, that the user of \textit{YAGAL} compiles the necessary components of \textit{LLVM} into her executable. This allow us to generate \textit{LLVM Intermediate Representation} and use \textit{LLVM}s back-ends to target \textit{PTX} inside the \textit{YAGAL} library.

When we can generate \textit{PTX} we can focus on executing it, which is done using the \textit{CUDA Driver API}. The \textit{CUDA Driver API} differ from the \textit{CUDA Runtime API} by being slightly more verbose, but allowing \textit{PTX} to be invoked, and not requiring the \textit{NVIDIA} compiler. Using the \textit{LLVM} library in conjunction with the \textit{CUDA Driver API} allow us to handle code generation and execution without requiring a specific compiler.

Using the \textit{LLVM} library and the \textit{CUDA Driver API} does impose dependencies that the user of \textit{YAGAL} is required to have available. So while the compiler choice is still up to the developer, the need to install these two libraries are still present as a prerequisite to using \textit{YAGAL}.

\todo{figur der viser library}

\subsection{CUDA Compatibility}
In cases where programs are unable to be expressed in \textit{YAGAL}, we want to provide a fall back solution. We intend to do this though letting the developer execute arbitrary \textit{PTX} code, through the \textit{CUDA Driver API}. To allow this we want our abstractions to provide access to the relevant device pointers to the GPU.

This solution still require the developer to have \textit{PTX} code that solves the problem. Normally this would mean writing \textit{CUDA} code, and compile that to \textit{PTX}, which is a long work around. As such it is not ideal, but we decide that it is better to provide a problematic work around, rather than none.