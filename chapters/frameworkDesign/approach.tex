\section{Design Approach}
We consider the \textit{YAGAL} framework as a combination of two entities; API and architecture.

The API is the front end of the framework, which is what a developer is going to see when using the framework. Designing the API is the task of defining the programming model of the framework, including what functions and types are made available to developers. The API design dictates the usage and learning experience for developers, and som principles to guide the development of this part is covered in Chapter \ref{cha:designPrinciples}.

The architecture is the structure of the framework, its run-time environment, its compilation process, and platform support. Architectural design decisions will define which use cases are possible to facilitate, and have an impact on how a developer is going to incorporate the framework into her work flow.

\subsection{Design Order}
As both the API and the architecture decisions have an influence on what is possible when designing the other, the order of which these get designed is important. Different approaches is discussed here.

\subsubsection{API First}
When the API is designed before the architecture, we expect the following pros and cons, in no specific order:

Pros:
\begin{itemize}
\item The API design and be done with ease of use as first priority.
\item The API design is more likely to not let implementation details propagate.
\item The architecture design can be developed against very specific tasks.
\end{itemize}

Cons:
\begin{itemize}
\item The architecture can be limited due to some API design decisions being unfeasible on some platforms, such as requiring features of a specific vendor.
\item The API usage might be too different from the underlying implementation, resulting in some computations being more expensive than needed, such as abstracting memory location can result in multiple redundant data transfers.
\item The requirements to the architecture might be impossible or self conflicting, such as two actions in the API being convenient based on two different underlying data structures.
\item The API design might require features that make the compilation process convoluted for the developer, such as requiring custom preprocessing before compilation.
\end{itemize}

In general, this approach is more likely to make our framework ergonomic to use, but it might be at at the cost of architectural simplicity. 

\subsubsection{Architecture First}
When the architecture is designed before the API, we expect the following pros and cons:

Pros:
\begin{itemize}
\item The framework structure will be simpler to explain.
\item Performance optimizations will be more convenient to implement.
\item Allow a convenient tool chain, with a well defined compilation process.
\end{itemize}

Cons:
\begin{itemize}
\item The API design might have implementation details revealed.
\item The API design might be constrained, due to limitations in the architecture.
\end{itemize}

In general, this approach is more likely to make our framework consistent, but it might come at a cost in the form of limitations in the API. 

%\subsubsection{Intertwined}
%When we design them at the same time, and allow design decisions of one to influence the other, we expect the following pros and cons:
%
%Pros:
%\begin{itemize}
%\item A coherent API design and architecture design.
%\end{itemize}
%
%Cons:
%\begin{itemize}
%\item Implementation details might be included in the API design.
%\end{itemize}

\subsubsection{Decision}
As the goal of this project is to make a framework that makes it fast and simple to try GPGPU accelerated code, we choose to design the API first, as it will put the ergonomics of the framework first. As making the underlying architecture work is an implementation problem for us, it is not a concern for a developer.